{% extends "base.html" %}

{% block title %}Content - Digital Signage Manager{% endblock %}

{% block content %}
<div class="card">
    <h2>Upload Content</h2>

    <!-- Drag and Drop Upload Zone -->
    <div class="upload-zone" id="uploadZone">
        <div class="upload-icon">üìÅ</div>
        <div class="upload-text">Drop files here or click to browse</div>
        <div class="upload-hint">
            Supports: Images (PNG, JPG, GIF, BMP) & Videos (MP4, AVI, MOV, WebM, MKV)<br>
            Max size: 500MB per file | Multiple files supported
        </div>
        <input type="file" id="fileInput" multiple accept="image/*,video/*" style="display: none;">
    </div>

    <!-- Upload Settings -->
    <div class="form-group">
        <label for="defaultDuration">Default Duration (seconds)</label>
        <input type="number" id="defaultDuration" value="10" min="1" style="max-width: 200px;">
        <span style="color: #666; font-size: 0.875rem; margin-left: 0.5rem;">Applied to all uploaded files</span>
    </div>

    <!-- Upload Queue -->
    <div id="uploadQueue" style="margin-top: 2rem;"></div>
</div>

<div class="card">
    <h2>Content Library</h2>
    {% if content_list %}
    <table>
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Duration</th>
                <th>Size</th>
                <th>Created</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody id="contentTableBody">
            {% for content in content_list %}
            <tr id="content-{{ content.id }}">
                <td>{{ content.name }}</td>
                <td>{{ content.content_type|capitalize }}</td>
                <td>{{ content.duration }}s</td>
                <td>{{ (content.file_size / 1024 / 1024)|round(2) }} MB</td>
                <td>{{ content.created_at.strftime('%Y-%m-%d %H:%M') }}</td>
                <td>
                    <button class="btn btn-danger" onclick="deleteContent({{ content.id }})">Delete</button>
                </td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
    {% else %}
    <p style="color: #666; text-align: center; padding: 2rem;">No content uploaded yet</p>
    {% endif %}
</div>
{% endblock %}

{% block scripts %}
<script>
    const uploadZone = document.getElementById('uploadZone');
    const fileInput = document.getElementById('fileInput');
    const uploadQueue = document.getElementById('uploadQueue');
    const defaultDuration = document.getElementById('defaultDuration');

    let uploadingFiles = [];

    // Click to browse
    uploadZone.addEventListener('click', () => {
        fileInput.click();
    });

    // Prevent default drag behaviors
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        uploadZone.addEventListener(eventName, preventDefaults, false);
        document.body.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }

    // Highlight drop zone when dragging over
    ['dragenter', 'dragover'].forEach(eventName => {
        uploadZone.addEventListener(eventName, () => {
            uploadZone.classList.add('dragover');
        }, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
        uploadZone.addEventListener(eventName, () => {
            uploadZone.classList.remove('dragover');
        }, false);
    });

    // Handle dropped files
    uploadZone.addEventListener('drop', (e) => {
        const files = e.dataTransfer.files;
        handleFiles(files);
    }, false);

    // Handle file input change
    fileInput.addEventListener('change', (e) => {
        handleFiles(e.target.files);
    });

    function handleFiles(files) {
        const fileArray = Array.from(files);

        if (fileArray.length === 0) return;

        // Clear file input
        fileInput.value = '';

        // Add files to queue and start uploading
        fileArray.forEach((file, index) => {
            setTimeout(() => uploadFile(file), index * 100); // Stagger uploads slightly
        });
    }

    function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
        else return (bytes / 1048576).toFixed(1) + ' MB';
    }

    function getFileIcon(type) {
        if (type.startsWith('image/')) return 'üñºÔ∏è';
        if (type.startsWith('video/')) return 'üé¨';
        return 'üìÑ';
    }

    function uploadFile(file) {
        const fileId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);

        // Create file item in queue
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        fileItem.id = `file-${fileId}`;

        // Extract filename without extension for default name
        const nameWithoutExt = file.name.substring(0, file.name.lastIndexOf('.')) || file.name;

        fileItem.innerHTML = `
            <div class="file-icon">${getFileIcon(file.type)}</div>
            <div class="file-info">
                <div class="file-name">${file.name}</div>
                <div class="file-size">${formatFileSize(file.size)}</div>
                <div class="progress">
                    <div class="progress-bar" id="progress-${fileId}" style="width: 0%"></div>
                </div>
            </div>
            <div class="file-status uploading" id="status-${fileId}">Uploading...</div>
        `;

        uploadQueue.appendChild(fileItem);

        // Create form data
        const formData = new FormData();
        formData.append('file', file);
        formData.append('name', ''); // Let backend auto-name from filename
        formData.append('duration', defaultDuration.value);

        // Upload with progress tracking
        const xhr = new XMLHttpRequest();

        xhr.upload.addEventListener('progress', (e) => {
            if (e.lengthComputable) {
                const percentComplete = (e.loaded / e.total) * 100;
                document.getElementById(`progress-${fileId}`).style.width = percentComplete + '%';
            }
        });

        xhr.addEventListener('load', () => {
            const progressBar = document.getElementById(`progress-${fileId}`);
            const statusDiv = document.getElementById(`status-${fileId}`);

            if (xhr.status === 200) {
                const response = JSON.parse(xhr.responseText);
                progressBar.style.width = '100%';
                statusDiv.className = 'file-status success';
                statusDiv.textContent = '‚úì Uploaded';

                // Add to content library table after a short delay
                setTimeout(() => {
                    fileItem.style.opacity = '0';
                    setTimeout(() => {
                        fileItem.remove();
                        checkIfAllUploadsComplete();
                    }, 300);
                }, 1500);
            } else {
                const error = JSON.parse(xhr.responseText);
                progressBar.style.width = '100%';
                progressBar.style.background = '#e74c3c';
                statusDiv.className = 'file-status error';
                statusDiv.textContent = '‚úó ' + (error.error || 'Upload failed');
            }
        });

        xhr.addEventListener('error', () => {
            const statusDiv = document.getElementById(`status-${fileId}`);
            statusDiv.className = 'file-status error';
            statusDiv.textContent = '‚úó Network error';
        });

        xhr.open('POST', '/api/upload');
        xhr.send(formData);

        uploadingFiles.push(fileId);
    }

    function checkIfAllUploadsComplete() {
        // If queue is empty, reload page to show new content
        if (uploadQueue.children.length === 0 && uploadingFiles.length > 0) {
            uploadingFiles = [];
            window.location.reload();
        }
    }

    async function deleteContent(contentId) {
        if (!confirm('Are you sure you want to delete this content?')) {
            return;
        }

        try {
            const response = await fetch(`/admin/content/${contentId}/delete`, {
                method: 'POST'
            });

            if (response.ok) {
                const row = document.getElementById(`content-${contentId}`);
                row.style.opacity = '0';
                setTimeout(() => row.remove(), 300);
            } else {
                alert('Failed to delete content');
            }
        } catch (error) {
            alert('Failed to delete content');
        }
    }
</script>
{% endblock %}
